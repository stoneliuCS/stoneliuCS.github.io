<!DOCTYPE html>
<html lang="en">
   <head>
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
      <link rel="stylesheet" href="/styles.css">
      <meta charset="UTF-8"/>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/python.min.js"></script>
      <script>
        hljs.highlightAll();
      </script>
   </head>
   <body class="page">
      <div class="container">
         <div class="title-bar">
            <div class="header">
               Stone Liu
            </div>
            <div class="tabs">
               <a href="/index.html" class=tab>home</a>
               <a href="/blog" class=tab>thoughts</a>
               <a href="/scratchpad" class=tab>scratchpad</a>
               <a href="https://github.com/stoneliuCS/resume/blob/main/StoneLiu_Resume.pdf" class=tab>resume</a>
            </div>
         </div>
         <hr/>
         <root><p>Given the roots of two binary trees p and q, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>

<p>The data definition is provided as follows:
<pre class="code-block"><code class="python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right</code></pre>

This is <em>a structurally recursive data definiton, one can also write the same in ISL+</em>

<pre class="code-block"><code class="racket">;; A TreeNode is one of:
;; (make-leaf val)
;; (make-treenode TreeNode TreeNode)

(define (tree-node-temp node)
  (cond [(leaf? node) (leaf-val node)]
        [(treenode? node) (...
                          (tree-node-temp (tree-node left))
                          (tree-node-temp (tree-node right)))]
  )
)</code></pre></p>

<p>Trees are structurally recursive data structures. They are also self-referential. Meaning recursion is the perfect way to tackle this problem.</p>
<pre class="code-block"><code class="python">def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:
    if (p is None and q is None):
        return True
    elif (p is None or q is None):
        return False
    else:
       return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)</code></pre>
</root>
         <div class="footer">
            <a href="https://github.com/stoneliuCS" class="footer-item">github: {at}stoneliuCS</a>
            <a href="https://www.linkedin.com/in/stone-liu/" class="footer-item">linkedin: {at}stone-liu</a>
            <a href="mailto: liu.sto@northeastern.edu" class="footer-item">email: liu{dot}sto{at}northeastern.edu</a>
         </div>
      </div>
   </body>
</html>